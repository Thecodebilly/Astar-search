from shapely import geometry
import pygame, random, math


def isinbounds(point):
    inbounds = True

    if point[1] > height or point[1] < 0:
        inbounds = False
    if point[0] > width or point[0] < 0:
        inbounds = False

    return inbounds


def definefixedarena():
    # map out coords for figure 3.31
    allTheGons.append(geometry.Polygon([(140, 110), (155, 195), (250, 220), (300, 105), (238, 20)]))
    pygame.draw.polygon(screen, color, [(140, 110), (155, 195), (250, 220), (300, 105), (238, 20)])
    allTheGons.append(geometry.Polygon([(304, 226), (341, 90), (379, 226)]))
    pygame.draw.polygon(screen, color, [(304, 226), (341, 90), (379, 226)])
    allTheGons.append(geometry.Polygon([(385, 137), (500, 64), (456, 21), (388, 27)]))
    pygame.draw.polygon(screen, color, [(385, 137), (500, 64), (456, 21), (388, 27)])
    allTheGons.append(geometry.Polygon([(516, 208), (630, 208), (630, 29), (516, 29)]))
    pygame.draw.polygon(screen, color, [(516, 208), (630, 208), (630, 29), (516, 29)])
    allTheGons.append(geometry.Polygon([(454, 181), (540, 250), (483, 304)]))
    pygame.draw.polygon(screen, color, [(454, 181), (540, 250), (483, 304)])
    allTheGons.append(geometry.Polygon([(168, 262), (441, 262), (441, 347), (168, 347)]))
    pygame.draw.polygon(screen, color, [(168, 262), (441, 262), (441, 347), (168, 347)])
    allTheGons.append(
        geometry.Polygon([(581, 257), (581, 257), (581, 320), (635, 351), (691, 323), (690, 257), (643, 216)]))
    pygame.draw.polygon(screen, color,
                        [(581, 257), (581, 257), (581, 320), (635, 351), (691, 323), (690, 257), (643, 216)])
    allTheGons.append(geometry.Polygon([(646, 52), (703, 227), (718, 58), (685, 26)]))
    pygame.draw.polygon(screen, color, [(646, 52), (703, 227), (718, 58), (685, 26)])

    pygame.draw.polygon(screen, (165, 42, 42), endpoints)
    pygame.draw.line(screen, (0, 0, 0), (width - 10, 5), (width, 5))
    lock = (width - 7.5, 2.5), (width - 2.5, 2.5), (width - 7.5, 7.5), (width - 2.5, 7.5)
    pygame.draw.polygon(screen, (192, 192, 192), lock)


class Polygon:
    pts = []
    drawing = []

    def __init__(self):

        self.tiltAngle = random.uniform(0, 1) * 2 * math.pi
        self.numSides = random.randint(3, 7)
        self.radius = random.uniform(.1, .50) * area / (width + height)
        self.x = random.uniform(.3, .7) * width
        self.y = random.uniform(.3, .7) * height

    def new(self):
        self.drawing.clear()
        self.pts.clear()

        for i in range(self.numSides):
            self.x = self.x + self.radius * math.cos(self.tiltAngle + math.pi * 2 * i / self.numSides)
            self.y = self.y + self.radius * math.sin(self.tiltAngle + math.pi * 2 * i / self.numSides)
            self.drawing.append([int(self.x), int(self.y)])
            self.pts.append(geometry.Point([int(self.x), int(self.y)]))

        intersection = True
        while intersection:
            intersection = False
            poly = geometry.Polygon([[p.x, p.y] for p in self.pts])
            if allTheGons:

                for u in range(len(allTheGons)):
                    intersection = poly.intersects(allTheGons[u])
                    if intersection:
                        Polygon.randomize(self)
                        break

        allTheGons.append(poly)

        pygame.draw.polygon(screen, color, self.drawing)
        pygame.draw.polygon(screen, (165, 42, 42), endpoints)
        pygame.draw.line(screen, (0, 0, 0), (width - 10, 5), (width, 5))
        lock = (width - 7.5, 2.5), (width - 2.5, 2.5), (width - 7.5, 7.5), (width - 2.5, 7.5)
        pygame.draw.polygon(screen, (192, 192, 192), lock)

    def randomize(self):
        self.pts.clear()
        self.drawing.clear()
        self.tiltAngle = random.uniform(0, 1) * 2 * math.pi
        self.numSides = random.randint(3, 10)
        self.radius = random.uniform(.1, .3) * area / (width + height)
        self.x = random.uniform(.4, .7) * width
        self.y = random.uniform(.1, .9) * height

        for i in range(self.numSides):
            self.x = self.x + self.radius * math.cos(self.tiltAngle + math.pi * 2 * i / self.numSides)
            self.y = self.y + self.radius * math.sin(self.tiltAngle + math.pi * 2 * i / self.numSides)
            self.drawing.append([int(self.x), int(self.y)])
            self.pts.append(geometry.Point([int(self.x), int(self.y)]))


class Node:
    def __init__(self, point, parent=None):
        self.point = point
        self.parent = parent
        self.g = 0
        self.u = 0
        self.h = 0

    def updateG(self, g):
        self.g += g

    def updateU(self, u):
        self.u = u

    def updateH(self, h):
        self.h = h

    def updateParent(self, parent):
        self.parent = parent

    def ZERO(self):
        self.u = 0
        self.g = 0
        self.h = 0


def euclidianDist(point1, point2):
    return math.sqrt((math.pow((point2[0] - point1[0]), 2)) + (math.pow((point2[1] - point1[1]), 2)))


def collides(point1, point2, alltheGons):
    line1 = geometry.LineString([point1, point2])

    itis = False
    for a in range(len(alltheGons)):
        if line1.within(alltheGons[a]):
            itis = True

    return itis


def ACTION(actionlocation, theGons):
    points = []
    lines = []
    linestoremove = []
    for q in range(len(theGons)):
        points = list(theGons[q].exterior.coords)

        for i in range(len(points) - 1):
            point = points.pop()
            lines.append(geometry.LineString([actionlocation, point]))
    for w in range(len(lines)):
        remove = False
        for a in range(len(theGons)):
            if lines[w].crosses(theGons[a]):
                remove = True
        if remove:
            linestoremove.append(lines[w])

    for a in range(len(linestoremove)):
        lines.remove(linestoremove[a])
    return lines


pygame.init()
totalquit = False
while not totalquit:
    color = (74, 150, 0)
    white = (255, 255, 255)
    width = 800
    height = 400
    area = width * height
    poly_num = random.randint(15, 25)
    speed = 5
    allTheGons = []
    endpoints = (width - 10, 0), (width, 0), (width, 10), (width - 10, 10)

    Polygons = []
    surfaces = []
    nodes = []

    # generating polygons
    totalquit = False
    theInput = True
    while theInput:
        Random = input("Do you want the pre-generated environment? (type quit to quit) ")
        Random = Random.strip().lower()
        if Random == "quit":
            totalquit = True
            break
        if Random == "yes":
            Random = False
            break
        else:
            if Random == "no":
                Random = True
                break
            else:
                print("Invalid input, type yes or no ")
    if totalquit:
        break
    c = input("Enter a C value. ")
    screen = pygame.display.set_mode((width, height))
    screen.fill((0, 10, 180))
    if Random:
        while len(Polygons) < poly_num:
            new = Polygon()
            Polygons.append(new)
            new.new()
            pygame.display.update()
    else:
        definefixedarena()
        pygame.display.update()
    # drawing line

    pygame.display.update()

    # lines from start
    location = (0, height)
    z = 0
    openList = []
    closedList = []

    allTheGons.append(geometry.Polygon(endpoints))
    lineOfSight = ACTION(location, allTheGons)
    goalloc = (width - 10, 10)
    goal = Node(goalloc, None)
    begin = Node(location, None)
    Node.ZERO(begin)
    Node.ZERO(goal)
    begin.updateH(euclidianDist(location, goal.point))

    openList.append(begin)
    currentNode = openList[0]

    while len(openList) > 0:
        lowest = True
        currentNode = openList[0]
        index = 0
        for z in range(len(openList)):
            if openList[z].u < currentNode.u:
                currentNode = openList[z]
                index = z

        # if lowest:
        # currentNode is lowest
        # index = 0

        closedList.append(openList.pop(index))

        if currentNode.point == goal.point:
            break

        lineOfSight = ACTION(currentNode.point, allTheGons)
        ports = []

        for n in range(len(lineOfSight)):
            newport = Node(lineOfSight[n].coords[1], currentNode)
            ports.append(newport)

        for port in ports:
            inList = False
            if collides(currentNode.point, port.point, allTheGons):
                inList = True
            if not isinbounds(port.point):
                inList = True
            if euclidianDist(currentNode.point, port.point) > float(c):
                inList = True
            for oldport in openList:
                if port.point == oldport.point:
                    inList = True

                    if port.g < oldport.g:
                        oldport.updateH(euclidianDist(currentNode.point, goal.point))
                        port.g = currentNode.g + euclidianDist(currentNode.point, port.point)
                        oldport.updateU((c - port.g)/port.h)
                        oldport.updateParent(currentNode)
                        continue
            for closedport in closedList:
                if port.point == closedport.point:
                    #print(port.point == closedport.point)
                    inList = True

            if inList is False:
                openList.append(port)
                # print(len(openList))
                pygame.draw.line(screen, (123, 123, 123), currentNode.point, port.point)
                pygame.display.update()
    if currentNode.parent is None:
        print("No path found")
    while currentNode.parent is not None:
        pygame.draw.line(screen, (255, 0, 0), currentNode.parent.point, currentNode.point)
        print(currentNode.point)
        currentNode = currentNode.parent
    print(currentNode.point)
    pygame.display.update()
    # when you reach goal backtrack with parents in order to get path to draw

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            quit()
